# Script de limpieza para eliminar patrones típicos de código generado por IA
# PowerShell script para limpiar el proyecto de Inventario CyC

param(
    [string]$ProjectPath = ".",
    [switch]$DryRun = $false
)

Write-Host " Iniciando limpieza del proyecto..." -ForegroundColor Green
Write-Host " Ruta del proyecto: $ProjectPath" -ForegroundColor Yellow

if ($DryRun) {
    Write-Host " MODO PRUEBA: No se realizarán cambios" -ForegroundColor Yellow
}

# Función para limpiar patrones comunes de IA
function Clean-AIPatterns {
    param([string]$FilePath)
    
    if (-not (Test-Path $FilePath)) {
        Write-Host " Archivo no encontrado: $FilePath" -ForegroundColor Red
        return
    }
    
    $content = Get-Content $FilePath -Raw
    $originalContent = $content
    $changes = 0
    
    # Patrones a limpiar
    $patterns = @{
        # Comentarios típicos de IA
        "//\s*(los datos de las kips|generated by ai|auto-generated|mock data)" = ""
        
        # Nombres de variables poco descriptivos
        "\\bconst\\s+([a-z]+)Mock\\s*=" = "const initial`$1Data ="
        "\\b([a-z]+)Mock\\b(?!\\s*=)" = "initial`$1Data"
        
        # Variables con nombres de una letra
        "\\b([a-z])\\s*=>\\s*\\1\\." = "item => item."
        "\\.filter\\(\\s*([a-z])\\s*=>" = ".filter(item =>"
        "\\.map\\(\\s*([a-z]),\\s*([a-z]+)\\s*=>" = ".map((item, index) =>"
        
        # Funciones con nombres poco descriptivos
        "\\bhandleAdd\\b" = "openAddModal"
        "\\bhandleEdit\\b" = "openEditModal"
        "\\bhandleSave\\b" = "handleFormSave"
        "\\bhandleDelete\\b" = "deleteItem"
        
        # Variables de estado mejoradas
        "\\bshowAdd\\b" = "isAddModalOpen"
        "\\bshowEdit\\b" = "isEditModalOpen"
        "\\beditIdx\\b" = "editingIndex"
        "\\bidx\\b" = "index"
        "\\bsetIdx\\b" = "setIndex"
        
        # Estilos inline excesivos (básico)
        'style=\\{\\{[^}]{100,}\\}\\}' = 'className="inline-styles-removed"'
    }
    
    foreach ($pattern in $patterns.Keys) {
        $replacement = $patterns[$pattern]
        if ($content -match $pattern) {
            $content = $content -replace $pattern, $replacement
            $changes++
        }
    }
    
    # Si hay cambios, guardar el archivo
    if ($changes -gt 0 -and -not $DryRun) {
        Set-Content $FilePath -Value $content -Encoding UTF8
        Write-Host " Limpiado: $FilePath ($changes cambios)" -ForegroundColor Green
    } elseif ($changes -gt 0) {
        Write-Host " [PRUEBA] Cambios detectados en: $FilePath ($changes cambios)" -ForegroundColor Cyan
    }
    
    return $changes
}

# Función para organizar imports
function Optimize-Imports {
    param([string]$FilePath)
    
    if (-not (Test-Path $FilePath)) { return }
    
    $content = Get-Content $FilePath -Raw
    
    # Detectar si es un archivo React
    if ($content -match "import.*React") {
        # Organizar imports de React
        $reactImports = @()
        $libraryImports = @()
        $localImports = @()
        $otherImports = @()
        
        $lines = $content -split "`n"
        $importSection = @()
        $afterImports = @()
        $inImports = $true
        
        foreach ($line in $lines) {
            if ($line -match "^import\s+") {
                $importSection += $line
            } elseif ($line.Trim() -eq "" -and $inImports) {
                # Línea vacía en imports
            } else {
                $inImports = $false
                $afterImports += $line
            }
        }
        
        # Clasificar imports
        foreach ($import in $importSection) {
            if ($import -match "from ['\"]react['\"]") {
                $reactImports += $import
            } elseif ($import -match "from ['\"][^./]") {
                $libraryImports += $import
            } elseif ($import -match "from ['\"][./]") {
                $localImports += $import
            } else {
                $otherImports += $import
            }
        }
        
        # Reorganizar imports si es necesario
        if ($importSection.Count -gt 0 -and -not $DryRun) {
            $organizedImports = @()
            $organizedImports += $reactImports | Sort-Object
            if ($libraryImports.Count -gt 0) {
                $organizedImports += ""
                $organizedImports += $libraryImports | Sort-Object
            }
            if ($localImports.Count -gt 0) {
                $organizedImports += ""
                $organizedImports += $localImports | Sort-Object
            }
            if ($otherImports.Count -gt 0) {
                $organizedImports += $otherImports | Sort-Object
            }
            
            $newContent = ($organizedImports + "" + $afterImports) -join "`n"
            Set-Content $FilePath -Value $newContent -Encoding UTF8
            Write-Host " Imports organizados: $FilePath" -ForegroundColor Blue
        }
    }
}

# Buscar archivos a limpiar
$jsxFiles = Get-ChildItem -Path $ProjectPath -Recurse -Include "*.jsx", "*.js" -Exclude "node_modules", "dist", "build"
$totalChanges = 0

Write-Host " Encontrados $($jsxFiles.Count) archivos JavaScript/React para revisar..." -ForegroundColor Cyan

foreach ($file in $jsxFiles) {
    $changes = Clean-AIPatterns -FilePath $file.FullName
    $totalChanges += $changes
    
    # Optimizar imports también
    if (-not $DryRun) {
        Optimize-Imports -FilePath $file.FullName
    }
}

Write-Host " Limpieza completada!" -ForegroundColor Green
Write-Host " Total de cambios realizados: $totalChanges" -ForegroundColor Yellow

if ($DryRun) {
    Write-Host " Para aplicar los cambios, ejecuta sin el parámetro -DryRun" -ForegroundColor Cyan
} else {
    Write-Host " Todos los cambios han sido guardados" -ForegroundColor Green
}

# Sugerencias adicionales
Write-Host ""
Write-Host " Sugerencias adicionales de limpieza manual:" -ForegroundColor Magenta
Write-Host "   • Revisar y reemplazar estilos inline por clases CSS" -ForegroundColor White
Write-Host "   • Añadir comentarios explicativos en lugar de genéricos" -ForegroundColor White
Write-Host "   • Revisar nombres de funciones y variables para mayor claridad" -ForegroundColor White
Write-Host "   • Agregar validaciones y manejo de errores más específicos" -ForegroundColor White
Write-Host "   • Considerar extracting custom hooks para lógica reutilizable" -ForegroundColor White